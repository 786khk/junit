# JUnit
## JUnit 이란
- JAVA에서 독립적으로 단위테스트를 지원하는 프레임워크
## Unit 테스트란 
- 소스코드의 특정 모듈이 의도된 대로 정확히 작동하는지 검증
- 보든 함수와 메서드에 대한 테스트케이스 작성하는 절차
### 특징 
- 호출될때 마다 새로운 인스턴스를 생성해 독립적인 테스트
- 테스트를 지원하는 어노테이션(@Test, @Before, @After)지원
- 테스트 실행시 클래스 이름 알파벳 순으로 실행
### 테스트 메서드 명명 규칙
     - [테스트 중인 힘수이름]_[메서드가 받는 파람]_return[기대값 데이터타입]()
     - "test" 접두어 사용하기
     - Should_예상동작_When_테스트대상상태
     - When_ 테스트대상_Expect_예상동작
     - Given_사전조건_When_테스트대상 상태_Then_예상 동작

## JUNIT 속성 - FIRST
### First - 빠르다.
- 실제 DB나 파일 입출력을 수행하지 않고 가상의 데이터로 테스트 한다.
### Isolated - 독립적으로 수행한다.
<!-- - 좋은 테스트 코드는 간결해야한다. 하나의 테스트 코드가 다른 테스트 코드와 산호작용 하거나 외부 소스에 의존하는 프로덕션코드에 대해 테스트를 수행할 경우 테스트를 깨트리며 통제할 수 없는 외부상황에 의해 테스트가 실패할 수 있다.  -->
- 다른 단위테스트나 같은 메서드에 있는 다른 테스트 케이스와도 의존하지 않는 고립된 상태여야 한다.
### Repeatable - 반복이 가능하다.
- 반복가능한 테스트는 실행할때마다 결과가 같아야 한다.

### Self-validating - 개발자 스스로 검증이 가능하다.
- 기대값을 바르게 작성하고 이를 자동으로 검증하게 해주는 단위테스트는 우리의 시간을 소모하는게 아니라 절약한다.
- 해당 작업(Act)의 결과값이 옳은지 스스로 검증 가능하며 이를 준비하는 작업 역시 스스로 수행할 수 있어야 한다.

### Timely - 적시에 사용한다.
- 단위 테스트는 수행할수록 어느 부분에 테스트가 필요지 명확하재기 때문에 태스트 대상 코드가 줄어들며 이런 경험이 반복될수록 테스트를 작성하기 쉬워진다.

## JUnit을 하는 이유
### 테스트 자동화
  - 비지니스로직이 변경되어도계속해서 프로그램이 올바르게 작동하는디 확인
  - 예상치 못한 버그를 찾을 수 있다.

### 신뢰성 향상
  - 코드의 신뢰성을 향상된다. 테스트 케이스를 통해 도든 부분이 예상대로 동갖하고 예외상황에 대한 대비가 되어있는지 확인할 수 있다.

### 리팩터링
  - 코드 리팩터링 또는 수정할 때 JUnit 테스트를 실행해 기존 기능영향받지않았는지 확인할 수 있다. 코드구저나 디자인개선하거나 수정할 때 안정성 보장에도 도움이 된다. 
    - 테스트 케이스의 안정성 확인
      - 이는 코드가 리팩토링 될 때 코드의 동작이 바뀔 수 있는데 JUnit을 사용하면 기존의 테스트 케이스를 실행해 코드변경으로 예상치 못한 오류가 발생하지 않도록 안정성을 확인.
    - 회귀 테스트 
      - 리팩터링 작업 후 코드가 여전이 예상대로 작동하는지 확인하는 것이 굉장히 중요한데 이전 작성한 테스트 케이스를 쉽게 실행해 코드 변경으로 인한 문제를 빠르게 감지
    - 지속적 통합과 지속적 전달(CICD) 
      - 리팩토링은 지속적 통합과 지속전 전달 프로세스의 핵심이 될수 있다. 코드변경후에고 계속 실행되므로 리팩토링이 코드의 안전성을 보장하는데 CICD파이프라인에서 중요한 역할을 한다.

### 개발자간 협업
  - JUnit을 사용해 여러 개발자가 동일한 코드베이스에서 작업시 변경으로 인한 문제를 최소화. 
  - 코드변경에 대한 문제를 신속하게 감지할 수 있는 도우고 개발자간 협업 강화

### 지속적 통합 지속적 전달
  - CICD프로세스에 통합되어 자동화 된 빌드 및 배포파이프라인이 중요한혁할을한다.
  - 테스트를 통과하지 못하면 코드가 빌드되지 않거아 배포되지 않도록 설정한다.
    - Q. 테스트 를 실패하는데 파이프라인을 보면 FAIL이 아니라 SUCCESS가 되는경우는 테스트에 실패한건가?
      - A. 이부분은 일부 테스트에서 예상치 못한 실패나 경고가 발생했기때문에 Unstabled가 된거다. 예상치 못한 결과가 나왔을 경우 예외 발생이 아니기 때문에 Exception이 발생하지 않았고 실제 Exceptiopn 이 발생했다면 빌드결과는 Failure가 됬을것.
      
### 프로그램 동작의 문서화
  - 테스트 케이스 코드 동작을 문서화한다. 테스트틑 코드가 어떻게 동작해야 하는지에 대한 사양이 될 수 있다.

## JUnit 라이프사이클
1. Test Class Initialization
   - 테스트 클래스 초기화.
   - @BeforeAll이 설정된 메서드를 실행한다.
   - 테스트 클래스 내 모든 메서드 실행 전 호출
2. Test Instance Creation
   - 테스트 인스턴스 생성
   - 테스트 클래스의 각 테스트 메서드마다 새로운 테스트 인스턴스가 생성된다.
3. Test Method Initialization
   - 테스트 인스턴스 초기화
   - @BeforeEach 메서드 실행. 각테스트 메서드 실행 전호출되는 메서드 초기화 및 준비

4. Test Method Execution 
   - 테스트 메서드 실행
   - 실테 테스트 코드 실행
5. Test Method Cleanup
  - 테스트 메서드 정리
  - @AfterEach 메서드 실행. 각테스트 메서드 실행 후 호출되는 메서드. 리소스 해제 또는 정리
6. Test Instance Destruction
  - 테스트 인스턴스 소멸
  - 테스트클래스의 모든 테스트 메서드가 실행이 완료된 루 해당 인스턴스 소멸
  - @AfterAll 메서드 실행, 모든 테스트 메서드가 실행된 루 호출되는 메서드. 클래스 수준의 정리 작업 수행

- 실제 테스트 코드는 컴파일러의 개입이 없다. 그래서 어노테이션으로 사전정의를 해야한다.
- JUnit은 JVM에서 실행환경을 제공해  JVM에서 동작한다. 테스트 클래스를 로드해 테스트 메서드를 실행하고 결과를 취합해 보고하는작업을 수행한다. 
- 테스트 도중 예외가 발생했을 때 해당 예외를 처리하고 테스트를 중지하거나 계속진행하는 등의 작업을 진행하지만 가비지컬렉션을 사용하지 않는다.
- 실제 JAVA에서 코드가 실행되고 메서드 내 객체가 메모리에 할당되는것처럼 JUnit도 똑같이 작동한다. 해당 메서드의 실행이 완료되면 메서드 실행컨텍스트는 종료되고 메모리에서 해제된다.
- Junit에 Mock으로 지정한 stub은 실행시 테스트 메서드를 reflectionAPI 를 이용해 호출되기 때문에 public으로 접근제어자를 사용해야한다.

```sql
+--------------------------+
| Test Class Initialization |
+--------------------------+
            |
            v
+--------------------------+
| Test Instance Creation   |
+--------------------------+
            |
            v
+--------------------------+
| Test Method Initialization|
+--------------------------+
            |
            v
+--------------------------+
| Test Method Execution     |
+--------------------------+
            |
            v
+--------------------------+
| Test Method Cleanup       |
+--------------------------+
            |
            v
+--------------------------+
| Test Instance Destruction |
+--------------------------+
            |
            v
+--------------------------+
| Test Class Cleanup        |
+--------------------------+
```

## JUnit의 클래스 구성
### 어노테이션 
- 테스트를 정의, 테스트 실행지원
- @Test, @Before, @After, @BeforeClass, @AfterClass 등이 일반적

#### TestClass
- 테스트 메서드 포함해 테스트 실시
- @Test어노테이션이 부여된 테스트를 하나이상 포함
- public 클래스여야만 하며 디폴트 생성자를 제공해야함

#### TestMethods
- test 내용이 들어있는 method
- public 이어야만 한다
- 파라미터를 받아서는 안됨
- void 로 반환해야 함

```java 
public class UnitTests{

  @Test
  public void myTestMethod(){

  }
}


```
### Assertions 그리고 AssertJ
- 예상되는 결과와 실제 결과를 비교하기위한 API제공.(테스트 검증)
- Spring에서 기본제공하는 API 는 Assertions, AssertionJ는 의존을 추가해야함
- assertEquals, assertTrue, assertFalse, assertNotNull 등이 있다.

### Test Runners
- 테스트 실행 및 결과 보고
- Junit38ClassRunner 하위 호환목적의 러너
- JUnit4 JUnit4스타일의 테스트 케이스 실행
- Parameterized 같은 테스트 케이스를 다른 입력값을 사용해 반복수행
- Suite 복수의 테스트를 묶을 수 있는 집합(테스트 클래스 내 @Test 메서드를 찾아 실행)

#### Parameterized Tests
- 매개변수 테스트를 지원. 
- 하나의 동일한 테스트 메서드를 여러개 다른 매개변수로 여러번 실행할 수 있다.
- @MethodSource 어노테이션을 사용하며 매개변수화된 테스트 작성
- Junit4에서는 @RunWith 어노테이션을 사용한다.
- 메서드에서 파라미터를 받을 때 타입이  Collection이어야 한다.
- 
### Test Suites
- 여러 테스트케이스를 하나의 그룹으로 묶어 실행할 수 있는 테스트 스위트 지원
- @RunWith으로 테스트 수트를 지원
- JUnit에서는 별도로 지정하지 않아도 모든 테스트를 포함하는 케스트 스위트를 자동으로 생성
- 같은 패키지 내 테스트 클래스들을 묶음
### Rules
- 테스트 메서드 실행 전 후 추가적인 동작을 정의할 수 있는 룰 제공
- @TemporaryFolder, @Timeout등의 룰을 사용해 테스트 메서드환경을 설정 또는 시간제한을 둘 수 있다.
### Extention
- Extention을 통해 수명주기 확장, 새로운 기능 추가 

- ParameterResolver, TestInstancePostProcessor 등이 있다.
```java
  @WebMvcTest(MyController.class)
  @ExtendWith(TestInstancePostProcessor.class)
  @TestInstance(Lifecycle.PER_METHOD)
  public class UnitTest {
      ...
  }

```

## JUnit기본 
### Platform
- 테스트 실행 환경
- 다양한 테스트 엔진 구현체 실행, 테스트 결과 보고
### TestEngine Interface
- JUnit Platform에서 테스트 엔진을 정의
- 사용자 정의 테스트 엔진을 만듦

### TestEngine
- JUnit Platform에서 테스트를 실행하는 데 사용되는 구현체
- 특정한 테스트 프레임워크 또는 런처와 통합되어 동작
- 테스트 수명주기 관리, 테스트 실행, 결과 보고 등의 기능을 제공

### JUnit Jupiter
- JUnit 5에서 제공되는 새로운 프레임워크
- 테스트 작성과 실행을 위한 새로운 기능과 어노테이션을 제공
- JUnit 4보다 더 강력하고 유연한 테스트 코드 작성이 가능

### JUnit Vintage
- JUnit 4와의 하위 호환성을 제공하기 위한 모듈

